import {
  _extends,
  _objectWithoutPropertiesLoose
} from "./chunk-Y67KMEH3.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/react-grid-dnd/node_modules/tslib/tslib.es6.js
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}

// node_modules/react-grid-dnd/esm/GridContext.js
var React = __toESM(require_react());

// node_modules/react-grid-dnd/esm/helpers.js
function getDragPosition(index2, grid, dx, dy, center) {
  var _a = __read(getPositionForIndex(index2, grid).xy, 2), left = _a[0], top = _a[1];
  return {
    xy: [
      left + dx + (center ? grid.columnWidth / 2 : 0),
      top + dy + (center ? grid.rowHeight / 2 : 0)
    ]
  };
}
function getPositionForIndex(i, _a, traverseIndex) {
  var boxesPerRow = _a.boxesPerRow, rowHeight = _a.rowHeight, columnWidth = _a.columnWidth;
  var index2 = typeof traverseIndex == "number" ? i >= traverseIndex ? i + 1 : i : i;
  var x = index2 % boxesPerRow * columnWidth;
  var y = Math.floor(index2 / boxesPerRow) * rowHeight;
  return {
    xy: [x, y]
  };
}
function getIndexFromCoordinates(x, y, _a, count) {
  var rowHeight = _a.rowHeight, boxesPerRow = _a.boxesPerRow, columnWidth = _a.columnWidth;
  var index2 = Math.floor(y / rowHeight) * boxesPerRow + Math.floor(x / columnWidth);
  return index2 >= count ? count : index2;
}
function getTargetIndex(startIndex, grid, count, dx, dy) {
  var _a = __read(getDragPosition(startIndex, grid, dx, dy, true).xy, 2), cx = _a[0], cy = _a[1];
  return getIndexFromCoordinates(cx, cy, grid, count);
}

// node_modules/react-grid-dnd/esm/GridContext.js
var noop = function() {
  throw new Error("Make sure that you have wrapped your drop zones with GridContext");
};
var GridContext = React.createContext({
  register: noop,
  remove: noop,
  getActiveDropId: noop,
  startTraverse: noop,
  measureAll: noop,
  traverse: null,
  endTraverse: noop,
  onChange: noop
});
function GridContextProvider(_a) {
  var children = _a.children, onChange = _a.onChange;
  var _b = __read(React.useState(null), 2), traverse = _b[0], setTraverse = _b[1];
  var dropRefs = React.useRef(/* @__PURE__ */ new Map());
  function register(id, options) {
    dropRefs.current.set(id, options);
  }
  function remove(id) {
    dropRefs.current.delete(id);
  }
  function getFixedPosition(sourceId, rx, ry) {
    var item = dropRefs.current.get(sourceId);
    if (!item) {
      return {
        x: rx,
        y: ry
      };
    }
    var left = item.left, top = item.top;
    return {
      x: left + rx,
      y: top + ry
    };
  }
  function getRelativePosition(targetId, fx, fy) {
    var _a2 = dropRefs.current.get(targetId), left = _a2.left, top = _a2.top;
    return {
      x: fx - left,
      y: fy - top
    };
  }
  function diffDropzones(sourceId, targetId) {
    var sBounds = dropRefs.current.get(sourceId);
    var tBounds = dropRefs.current.get(targetId);
    return {
      x: tBounds.left - sBounds.left,
      y: tBounds.top - sBounds.top
    };
  }
  function getActiveDropId(sourceId, x, y) {
    var e_1, _a2;
    var _b2 = getFixedPosition(sourceId, x, y), fx = _b2.x, fy = _b2.y;
    try {
      for (var _c = __values(dropRefs.current.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
        var _e = __read(_d.value, 2), key = _e[0], bounds = _e[1];
        if (!bounds.disableDrop && fx > bounds.left && fx < bounds.right && fy > bounds.top && fy < bounds.bottom) {
          return key;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a2 = _c.return))
          _a2.call(_c);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return null;
  }
  function startTraverse(sourceId, targetId, x, y, sourceIndex) {
    var _a2 = getFixedPosition(sourceId, x, y), fx = _a2.x, fy = _a2.y;
    var _b2 = getRelativePosition(targetId, fx, fy), rx = _b2.x, ry = _b2.y;
    var _c = dropRefs.current.get(targetId), targetGrid = _c.grid, count = _c.count;
    var targetIndex = getIndexFromCoordinates(rx + targetGrid.columnWidth / 2, ry + targetGrid.rowHeight / 2, targetGrid, count);
    var _d = __read(getPositionForIndex(targetIndex, targetGrid).xy, 2), px = _d[0], py = _d[1];
    var _e = diffDropzones(sourceId, targetId), dx = _e.x, dy = _e.y;
    if (!traverse || !(traverse && traverse.targetIndex !== targetIndex && traverse.targetId !== targetId)) {
      setTraverse({
        rx: px + dx,
        ry: py + dy,
        tx: rx,
        ty: ry,
        sourceId,
        targetId,
        sourceIndex,
        targetIndex
      });
    }
  }
  function endTraverse() {
    setTraverse(null);
  }
  function onSwitch(sourceId, sourceIndex, targetIndex, targetId) {
    setTraverse(__assign({}, traverse, { execute: true }));
    onChange(sourceId, sourceIndex, targetIndex, targetId);
  }
  function measureAll() {
    dropRefs.current.forEach(function(ref) {
      ref.remeasure();
    });
  }
  return React.createElement(GridContext.Provider, { value: {
    register,
    remove,
    getActiveDropId,
    startTraverse,
    traverse,
    measureAll,
    endTraverse,
    onChange: onSwitch
  } }, children);
}

// node_modules/react-grid-dnd/esm/GridDropZone.js
var React4 = __toESM(require_react());

// node_modules/react-grid-dnd/esm/use-measure.js
var React2 = __toESM(require_react());

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = (
  /** @class */
  function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
var ResizeObserver_es_default = index;

// node_modules/react-grid-dnd/esm/use-measure.js
function useMeasure(ref) {
  var _a = __read(React2.useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0
  }), 2), bounds = _a[0], setBounds = _a[1];
  var _b = __read(React2.useState(function() {
    return new ResizeObserver_es_default(function(_a2) {
      var _b2 = __read(_a2, 1), entry = _b2[0];
      setBounds(entry.target.getBoundingClientRect());
    });
  }), 1), observer = _b[0];
  React2.useLayoutEffect(function() {
    if (ref.current) {
      observer.observe(ref.current);
    }
    return function() {
      return observer.disconnect();
    };
  }, [ref, observer]);
  function remeasure() {
    setBounds(ref.current.getBoundingClientRect());
  }
  return { bounds, remeasure };
}

// node_modules/react-grid-dnd/esm/swap.js
function swap(array, moveIndex, toIndex) {
  var item = array[moveIndex];
  var length = array.length;
  var diff = moveIndex - toIndex;
  if (diff > 0) {
    return __spread(array.slice(0, toIndex), [
      item
    ], array.slice(toIndex, moveIndex), array.slice(moveIndex + 1, length));
  } else if (diff < 0) {
    var targetIndex = toIndex + 1;
    return __spread(array.slice(0, moveIndex), array.slice(moveIndex + 1, targetIndex), [
      item
    ], array.slice(targetIndex, length));
  }
  return array;
}

// node_modules/react-grid-dnd/esm/GridItemContext.js
var React3 = __toESM(require_react());
var GridItemContext = React3.createContext(null);

// node_modules/react-grid-dnd/esm/GridDropZone.js
function GridDropZone(_a) {
  var id = _a.id, boxesPerRow = _a.boxesPerRow, children = _a.children, style = _a.style, _b = _a.disableDrag, disableDrag = _b === void 0 ? false : _b, _c = _a.disableDrop, disableDrop = _c === void 0 ? false : _c, rowHeight = _a.rowHeight, other = __rest(_a, ["id", "boxesPerRow", "children", "style", "disableDrag", "disableDrop", "rowHeight"]);
  var _d = React4.useContext(GridContext), traverse = _d.traverse, startTraverse = _d.startTraverse, endTraverse = _d.endTraverse, register = _d.register, measureAll = _d.measureAll, onChange = _d.onChange, remove = _d.remove, getActiveDropId = _d.getActiveDropId;
  var ref = React4.useRef(null);
  var _e = useMeasure(ref), bounds = _e.bounds, remeasure = _e.remeasure;
  var _f = __read(React4.useState(null), 2), draggingIndex = _f[0], setDraggingIndex = _f[1];
  var _g = __read(React4.useState(null), 2), placeholder = _g[0], setPlaceholder = _g[1];
  var traverseIndex = traverse && !traverse.execute && traverse.targetId === id ? traverse.targetIndex : null;
  var grid = {
    columnWidth: bounds.width / boxesPerRow,
    boxesPerRow,
    rowHeight
  };
  var childCount = React4.Children.count(children);
  React4.useEffect(function() {
    register(id, {
      top: bounds.top,
      bottom: bounds.bottom,
      left: bounds.left,
      right: bounds.right,
      width: bounds.width,
      height: bounds.height,
      count: childCount,
      grid,
      disableDrop,
      remeasure
    });
  }, [childCount, disableDrop, bounds, id, grid]);
  React4.useEffect(function() {
    return function() {
      return remove(id);
    };
  }, [id]);
  var itemsIndexes = React4.Children.map(children, function(_, i) {
    return i;
  });
  return React4.createElement("div", __assign({ ref, style: __assign({ position: "relative" }, style) }, other), grid.columnWidth === 0 ? null : React4.Children.map(children, function(child, i) {
    var isTraverseTarget = traverse && traverse.targetId === id && traverse.targetIndex === i;
    var order = placeholder ? swap(itemsIndexes, placeholder.startIndex, placeholder.targetIndex) : itemsIndexes;
    var pos = getPositionForIndex(order.indexOf(i), grid, traverseIndex);
    function onMove(state, x, y) {
      if (!ref.current)
        return;
      if (draggingIndex !== i) {
        setDraggingIndex(i);
      }
      var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);
      if (targetDropId && targetDropId !== id) {
        startTraverse(id, targetDropId, x, y, i);
      } else {
        endTraverse();
      }
      var targetIndex = targetDropId !== id ? childCount : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);
      if (targetIndex !== i) {
        if (placeholder && placeholder.targetIndex !== targetIndex || !placeholder) {
          setPlaceholder({
            targetIndex,
            startIndex: i
          });
        }
      } else if (placeholder) {
        setPlaceholder(null);
      }
    }
    function onEnd(state, x, y) {
      var targetDropId = getActiveDropId(id, x + grid.columnWidth / 2, y + grid.rowHeight / 2);
      var targetIndex = targetDropId !== id ? childCount : getTargetIndex(i, grid, childCount, state.delta[0], state.delta[1]);
      if (traverse) {
        onChange(traverse.sourceId, traverse.sourceIndex, traverse.targetIndex, traverse.targetId);
      } else {
        onChange(id, i, targetIndex);
      }
      setPlaceholder(null);
      setDraggingIndex(null);
    }
    function onStart() {
      measureAll();
    }
    return React4.createElement(GridItemContext.Provider, { value: {
      top: pos.xy[1],
      disableDrag,
      endTraverse,
      mountWithTraverseTarget: isTraverseTarget ? [traverse.tx, traverse.ty] : void 0,
      left: pos.xy[0],
      i,
      onMove,
      onEnd,
      onStart,
      grid,
      dragging: i === draggingIndex
    } }, child);
  }));
}

// node_modules/react-grid-dnd/esm/move.js
function move(source, destination, droppableSource, droppableDestination) {
  var sourceClone = Array.from(source);
  var destClone = Array.from(destination);
  var _a = __read(sourceClone.splice(droppableSource, 1), 1), removed = _a[0];
  destClone.splice(droppableDestination, 0, removed);
  return [sourceClone, destClone];
}

// node_modules/react-grid-dnd/esm/GridItem.js
var React7 = __toESM(require_react());

// node_modules/react-gesture-responder/node_modules/tslib/tslib.es6.js
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};

// node_modules/react-gesture-responder/esm/index.js
var React5 = __toESM(require_react());

// node_modules/react-gesture-responder/esm/mouse-enabled.js
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var isEnabled = false;
var MOUSE_MOVE_THRESHOLD = 1e3;
var lastTouchTimestamp = 0;
function enableMouse() {
  if (isEnabled || Date.now() - lastTouchTimestamp < MOUSE_MOVE_THRESHOLD) {
    return;
  }
  isEnabled = true;
}
function disableMouse() {
  lastTouchTimestamp = Date.now();
  if (isEnabled) {
    isEnabled = false;
  }
}
if (canUseDOM) {
  document.addEventListener("touchstart", disableMouse, true);
  document.addEventListener("touchmove", disableMouse, true);
  document.addEventListener("mousemove", enableMouse, true);
}
function isMouseEnabled() {
  return isEnabled;
}

// node_modules/react-gesture-responder/esm/index.js
var initialState = {
  time: Date.now(),
  xy: [0, 0],
  delta: [0, 0],
  initial: [0, 0],
  previous: [0, 0],
  direction: [0, 0],
  initialDirection: [0, 0],
  local: [0, 0],
  lastLocal: [0, 0],
  velocity: 0,
  distance: 0
};
var defaultConfig = {
  enableMouse: true
};
var grantedTouch = null;
function useGestureResponder(options, config) {
  if (options === void 0) {
    options = {};
  }
  if (config === void 0) {
    config = {};
  }
  var state = React5.useRef(initialState);
  var _a = __assign2({}, defaultConfig, config), uid = _a.uid, enableMouse2 = _a.enableMouse;
  var id = React5.useRef(uid || Math.random());
  var pressed = React5.useRef(false);
  var callbackRefs = React5.useRef(options);
  React5.useEffect(function() {
    callbackRefs.current = options;
  }, [options]);
  function claimTouch(e) {
    if (grantedTouch && grantedTouch.onTerminationRequest(e)) {
      grantedTouch.onTerminate(e);
      grantedTouch = null;
    }
    attemptGrant(e);
  }
  function attemptGrant(e) {
    if (grantedTouch) {
      return;
    }
    grantedTouch = {
      id: id.current,
      onTerminate,
      onTerminationRequest
    };
    onGrant(e);
  }
  function bindGlobalMouseEvents() {
    window.addEventListener("mousemove", handleMoveMouse, false);
    window.addEventListener("mousemove", handleMoveMouseCapture, true);
    window.addEventListener("mouseup", handleEndMouse);
  }
  function unbindGlobalMouseEvents() {
    window.removeEventListener("mousemove", handleMoveMouse, false);
    window.removeEventListener("mousemove", handleMoveMouseCapture, true);
    window.removeEventListener("mouseup", handleEndMouse);
  }
  function handleStartCapture(e) {
    updateStartState(e);
    pressed.current = true;
    var granted = onStartShouldSetCapture(e);
    if (granted) {
      attemptGrant(e);
    }
  }
  function handleStart(e) {
    updateStartState(e);
    pressed.current = true;
    bindGlobalMouseEvents();
    var granted = onStartShouldSet(e);
    if (granted) {
      attemptGrant(e);
    }
  }
  function isGrantedTouch() {
    return grantedTouch && grantedTouch.id === id.current;
  }
  function handleEnd(e) {
    pressed.current = false;
    unbindGlobalMouseEvents();
    if (!isGrantedTouch()) {
      return;
    }
    grantedTouch = null;
    onRelease(e);
  }
  function handleMoveCapture(e) {
    updateMoveState(e);
    if (isGrantedTouch()) {
      return;
    }
    if (onMoveShouldSetCapture(e)) {
      claimTouch(e);
    }
  }
  function handleMove(e) {
    if (isGrantedTouch()) {
      onMove(e);
      return;
    }
    if (onMoveShouldSet(e)) {
      claimTouch(e);
    }
  }
  function onStartShouldSet(e) {
    return callbackRefs.current.onStartShouldSet ? callbackRefs.current.onStartShouldSet(state.current, e) : false;
  }
  function onStartShouldSetCapture(e) {
    return callbackRefs.current.onStartShouldSetCapture ? callbackRefs.current.onStartShouldSetCapture(state.current, e) : false;
  }
  function onMoveShouldSet(e) {
    return callbackRefs.current.onMoveShouldSet ? callbackRefs.current.onMoveShouldSet(state.current, e) : false;
  }
  function onMoveShouldSetCapture(e) {
    return callbackRefs.current.onMoveShouldSetCapture ? callbackRefs.current.onMoveShouldSetCapture(state.current, e) : false;
  }
  function onGrant(e) {
    if (callbackRefs.current.onGrant) {
      callbackRefs.current.onGrant(state.current, e);
    }
  }
  function updateStartState(e) {
    var _a2 = e.touches && e.touches[0] ? e.touches[0] : e, pageX = _a2.pageX, pageY = _a2.pageY;
    var s = state.current;
    state.current = __assign2({}, initialState, { lastLocal: s.lastLocal || initialState.lastLocal, xy: [pageX, pageY], initial: [pageX, pageY], previous: [pageX, pageY], time: Date.now() });
  }
  function updateMoveState(e) {
    var _a2 = e.touches && e.touches[0] ? e.touches[0] : e, pageX = _a2.pageX, pageY = _a2.pageY;
    var s = state.current;
    var time = Date.now();
    var x_dist = pageX - s.xy[0];
    var y_dist = pageY - s.xy[1];
    var delta_x = pageX - s.initial[0];
    var delta_y = pageY - s.initial[1];
    var distance = Math.sqrt(delta_x * delta_x + delta_y * delta_y);
    var len = Math.sqrt(x_dist * x_dist + y_dist * y_dist);
    var scaler = 1 / (len || 1);
    var velocity = len / (time - s.time);
    var initialDirection = s.initialDirection[0] !== 0 || s.initialDirection[1] !== 0 ? s.initialDirection : [delta_x * scaler, delta_y * scaler];
    state.current = __assign2({}, state.current, { time, xy: [pageX, pageY], initialDirection, delta: [delta_x, delta_y], local: [
      s.lastLocal[0] + pageX - s.initial[0],
      s.lastLocal[1] + pageY - s.initial[1]
    ], velocity: time - s.time === 0 ? s.velocity : velocity, distance, direction: [x_dist * scaler, y_dist * scaler], previous: s.xy });
  }
  function onMove(e) {
    if (pressed.current && callbackRefs.current.onMove) {
      callbackRefs.current.onMove(state.current, e);
    }
  }
  function onRelease(e) {
    var s = state.current;
    state.current = __assign2({}, state.current, { lastLocal: s.local });
    if (callbackRefs.current.onRelease) {
      callbackRefs.current.onRelease(state.current, e);
    }
    grantedTouch = null;
  }
  function onTerminationRequest(e) {
    return callbackRefs.current.onTerminationRequest ? callbackRefs.current.onTerminationRequest(state.current, e) : true;
  }
  function onTerminate(e) {
    var s = state.current;
    state.current = __assign2({}, state.current, { lastLocal: s.local });
    if (callbackRefs.current.onTerminate) {
      callbackRefs.current.onTerminate(state.current, e);
    }
  }
  function handleMoveMouse(e) {
    if (isMouseEnabled()) {
      handleMove(e);
    }
  }
  function handleMoveMouseCapture(e) {
    if (isMouseEnabled()) {
      handleMoveCapture(e);
    }
  }
  function handleEndMouse(e) {
    if (isMouseEnabled()) {
      handleEnd(e);
    }
  }
  React5.useEffect(function() {
    return unbindGlobalMouseEvents;
  }, []);
  function terminateCurrentResponder() {
    if (grantedTouch) {
      grantedTouch.onTerminate();
      grantedTouch = null;
    }
  }
  function getCurrentResponder() {
    return grantedTouch;
  }
  var touchEvents = {
    onTouchStart: handleStart,
    onTouchEnd: handleEnd,
    onTouchMove: handleMove,
    onTouchStartCapture: handleStartCapture,
    onTouchMoveCapture: handleMoveCapture
  };
  var mouseEvents = enableMouse2 ? {
    onMouseDown: function(e) {
      if (isMouseEnabled()) {
        handleStart(e);
      }
    },
    onMouseDownCapture: function(e) {
      if (isMouseEnabled()) {
        handleStartCapture(e);
      }
    }
  } : {};
  return {
    bind: __assign2({}, touchEvents, mouseEvents),
    terminateCurrentResponder,
    getCurrentResponder
  };
}

// node_modules/react-spring/web.js
var import_react = __toESM(require_react());
var applyAnimatedValues;
var createStringInterpolator;
var now = () => Date.now();
var colorNames = {};
var defaultElement;
var manualFrameloop;
var createAnimatedStyle;
var createAnimatedTransform;
var createAnimatedInterpolation;
var createAnimatedRef = (node) => node.current;
var requestAnimationFrame2 = typeof window !== "undefined" ? window.requestAnimationFrame : () => {
};
var cancelAnimationFrame = typeof window !== "undefined" ? window.cancelAnimationFrame : () => {
};
var assign = (globals) => {
  var _Object$assign = Object.assign({
    colorNames,
    defaultElement,
    applyAnimatedValues,
    createStringInterpolator,
    createAnimatedInterpolation,
    createAnimatedTransform,
    createAnimatedStyle,
    createAnimatedRef,
    requestAnimationFrame: requestAnimationFrame2,
    cancelAnimationFrame,
    manualFrameloop
  }, globals);
  colorNames = _Object$assign.colorNames;
  defaultElement = _Object$assign.defaultElement;
  applyAnimatedValues = _Object$assign.applyAnimatedValues;
  createStringInterpolator = _Object$assign.createStringInterpolator;
  createAnimatedInterpolation = _Object$assign.createAnimatedInterpolation;
  createAnimatedTransform = _Object$assign.createAnimatedTransform;
  createAnimatedStyle = _Object$assign.createAnimatedStyle;
  createAnimatedRef = _Object$assign.createAnimatedRef;
  requestAnimationFrame2 = _Object$assign.requestAnimationFrame;
  cancelAnimationFrame = _Object$assign.cancelAnimationFrame;
  manualFrameloop = _Object$assign.manualFrameloop;
  return _Object$assign;
};
var Globals = Object.freeze({
  get applyAnimatedValues() {
    return applyAnimatedValues;
  },
  get createStringInterpolator() {
    return createStringInterpolator;
  },
  now,
  get colorNames() {
    return colorNames;
  },
  get defaultElement() {
    return defaultElement;
  },
  get manualFrameloop() {
    return manualFrameloop;
  },
  get createAnimatedStyle() {
    return createAnimatedStyle;
  },
  get createAnimatedTransform() {
    return createAnimatedTransform;
  },
  get createAnimatedInterpolation() {
    return createAnimatedInterpolation;
  },
  get createAnimatedRef() {
    return createAnimatedRef;
  },
  get requestAnimationFrame() {
    return requestAnimationFrame2;
  },
  get cancelAnimationFrame() {
    return cancelAnimationFrame;
  },
  assign
});
var Animated = class {
  constructor() {
    this.payload = void 0;
    this.children = [];
  }
  getAnimatedValue() {
    return this.getValue();
  }
  getPayload() {
    return this.payload || this;
  }
  attach() {
  }
  detach() {
  }
  getChildren() {
    return this.children;
  }
  addChild(child) {
    if (this.children.length === 0)
      this.attach();
    this.children.push(child);
  }
  removeChild(child) {
    const index2 = this.children.indexOf(child);
    this.children.splice(index2, 1);
    if (this.children.length === 0)
      this.detach();
  }
};
var AnimatedArray = class extends Animated {
  constructor() {
    super(...arguments);
    this.payload = void 0;
  }
  attach() {
    this.payload.forEach((p) => p instanceof Animated && p.addChild(this));
  }
  detach() {
    this.payload.forEach((p) => p instanceof Animated && p.removeChild(this));
  }
};
var AnimatedObject = class extends Animated {
  constructor(payload) {
    super();
    this.payload = payload;
  }
  getValue(animated) {
    if (animated === void 0) {
      animated = false;
    }
    const payload = {};
    for (const key in this.payload) {
      const value = this.payload[key];
      if (animated && !(value instanceof Animated))
        continue;
      payload[key] = value instanceof Animated ? value[animated ? "getAnimatedValue" : "getValue"]() : value;
    }
    return payload;
  }
  getAnimatedValue() {
    return this.getValue(true);
  }
  attach() {
    Object.values(this.payload).forEach((s) => s instanceof Animated && s.addChild(this));
  }
  detach() {
    Object.values(this.payload).forEach((s) => s instanceof Animated && s.removeChild(this));
  }
};
var AnimatedStyle = class extends AnimatedObject {
  constructor(style) {
    if (style === void 0) {
      style = {};
    }
    super(style.transform && createAnimatedTransform ? _extends({}, style, {
      transform: createAnimatedTransform(style.transform)
    }) : style);
  }
};
var is = {
  arr: Array.isArray,
  obj: (a) => Object.prototype.toString.call(a) === "[object Object]",
  fun: (a) => typeof a === "function",
  str: (a) => typeof a === "string",
  num: (a) => typeof a === "number",
  und: (a) => a === void 0,
  boo: (a) => typeof a === "boolean"
};
function useForceUpdate() {
  const _useState = (0, import_react.useState)(false), f = _useState[1];
  const forceUpdate = (0, import_react.useCallback)(() => f((v) => !v), []);
  return forceUpdate;
}
function withDefault(value, defaultValue) {
  return value == null ? defaultValue : value;
}
function toArray(a) {
  return is.und(a) ? [] : Array.isArray(a) ? a : [a];
}
function callProp(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return is.fun(obj) ? obj(...args) : obj;
}
function getForwardProps(props) {
  const to = props.to, from = props.from, config = props.config, onStart = props.onStart, onRest = props.onRest, onFrame = props.onFrame, children = props.children, cancel = props.cancel, reset = props.reset, reverse = props.reverse, force = props.force, immediate = props.immediate, delay = props.delay, attach = props.attach, destroyed = props.destroyed, interpolateTo2 = props.interpolateTo, ref = props.ref, lazy = props.lazy, forward = _objectWithoutPropertiesLoose(props, ["to", "from", "config", "onStart", "onRest", "onFrame", "children", "cancel", "reset", "reverse", "force", "immediate", "delay", "attach", "destroyed", "interpolateTo", "ref", "lazy"]);
  return forward;
}
function interpolateTo(props) {
  const forward = getForwardProps(props);
  props = Object.entries(props).reduce((props2, _ref) => {
    let key = _ref[0], value = _ref[1];
    return key in forward || (props2[key] = value), props2;
  }, {});
  return _extends({
    to: forward
  }, props);
}
function handleRef(ref, forward) {
  if (forward) {
    if (is.fun(forward))
      forward(ref);
    else if (is.obj(forward)) {
      forward.current = ref;
    }
  }
  return ref;
}
function usePrev(value) {
  const prevRef = (0, import_react.useRef)(void 0);
  const prev = prevRef.current;
  prevRef.current = value;
  return prev;
}
function fillArray(length, mapIndex) {
  const arr = [];
  for (let i = 0; i < length; i++)
    arr.push(mapIndex(i));
  return arr;
}
function freeze(obj) {
  if (typeof process !== "undefined" && true) {
    return Object.freeze(obj);
  }
  return obj;
}
var AnimatedValueArray = class extends AnimatedArray {
  constructor(values) {
    super();
    this.payload = values;
  }
  getValue() {
    return this.payload.map((v) => v.getValue());
  }
  setValue(value, flush) {
    if (flush === void 0) {
      flush = true;
    }
    if (is.arr(value)) {
      if (value.length === this.payload.length) {
        value.forEach((v, i) => this.payload[i].setValue(v, flush));
      }
    } else {
      this.payload.forEach((p) => p.setValue(value, flush));
    }
  }
  interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return createAnimatedInterpolation(this, ...args);
  }
};
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator(range);
  }
  const config = range;
  const outputRange = config.output;
  const inputRange = config.range || [0, 1];
  const extrapolateLeft = config.extrapolateLeft || config.extrapolate || "extend";
  const extrapolateRight = config.extrapolateRight || config.extrapolate || "extend";
  const easing = config.easing || ((t) => t);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(input, inputRange[range2], inputRange[range2 + 1], outputRange[range2], outputRange[range2 + 1], easing, extrapolateLeft, extrapolateRight, config.map);
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i)
    if (inputRange[i] >= input)
      break;
  return i - 1;
}
var AnimatedInterpolation = class extends AnimatedArray {
  constructor(parents, args) {
    super();
    this.calc = void 0;
    this.calc = createInterpolator(...args);
    this.payload = Array.isArray(parents) ? parents : parents instanceof AnimatedValueArray ? parents.getPayload() : [parents];
  }
  getValue() {
    const args = this.payload.map((value) => value.getValue());
    return this.calc(...args);
  }
  interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return createAnimatedInterpolation(this, ...args);
  }
};
var active = false;
var controllers = /* @__PURE__ */ new Set();
var update = () => {
  if (!active)
    return false;
  let time = now();
  for (let controller of controllers) {
    let isActive = false;
    let updateCount = 0;
    for (let configIdx = 0; configIdx < controller.configs.length; configIdx++) {
      let config = controller.configs[configIdx];
      let endOfAnimation, lastTime;
      for (let valIdx = 0; valIdx < config.animatedValues.length; valIdx++) {
        let animated = config.animatedValues[valIdx];
        if (animated.done)
          continue;
        updateCount++;
        let to = config.toValues[valIdx];
        let isAnimated = to instanceof Animated;
        if (isAnimated)
          to = to.getValue();
        if (config.immediate) {
          animated.setValue(to);
          animated.done = true;
          continue;
        }
        let from = config.fromValues[valIdx];
        if (typeof from === "string" || typeof to === "string") {
          animated.setValue(to);
          animated.done = true;
          continue;
        }
        let position = animated.lastPosition;
        let velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[valIdx] : config.initialVelocity;
        if (config.duration !== void 0) {
          position = from + config.easing((time - animated.startTime) / config.duration) * (to - from);
          endOfAnimation = time >= animated.startTime + config.duration;
        } else if (config.decay) {
          const decay = config.decay === true ? 0.998 : config.decay;
          position = from + velocity / (1 - decay) * (1 - Math.exp(-(1 - decay) * (time - animated.startTime)));
          endOfAnimation = Math.abs(animated.lastPosition - position) < 0.1;
          if (endOfAnimation)
            to = position;
        } else {
          lastTime = animated.lastTime !== void 0 ? animated.lastTime : time;
          velocity = animated.lastVelocity !== void 0 ? animated.lastVelocity : config.initialVelocity;
          if (time > lastTime + 64)
            lastTime = time;
          let numSteps = Math.floor(time - lastTime);
          for (let i = 0; i < numSteps; ++i) {
            let force = -config.tension * (position - to);
            let damping = -config.friction * velocity;
            let acceleration = (force + damping) / config.mass;
            velocity = velocity + acceleration * 1 / 1e3;
            position = position + velocity * 1 / 1e3;
          }
          let isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;
          let isVelocity = Math.abs(velocity) <= config.precision;
          let isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;
          endOfAnimation = isOvershooting || isVelocity && isDisplacement;
          animated.lastVelocity = velocity;
          animated.lastTime = time;
        }
        if (isAnimated && !config.toValues[valIdx].done) {
          endOfAnimation = false;
        }
        if (endOfAnimation) {
          if (animated.value !== to)
            position = to;
          animated.done = true;
        } else {
          isActive = true;
        }
        animated.setValue(position);
        animated.lastPosition = position;
      }
      if (controller.props.onFrame) {
        controller.values[config.key] = config.animated.getValue();
      }
    }
    controller.onFrame(isActive, updateCount);
  }
  if (controllers.size) {
    if (manualFrameloop)
      manualFrameloop();
    else
      requestAnimationFrame2(update);
  } else {
    active = false;
  }
  return active;
};
var start = (controller) => {
  controllers.add(controller);
  if (!active) {
    active = true;
    if (manualFrameloop)
      manualFrameloop();
    else
      requestAnimationFrame2(update);
  }
};
var stop = (controller) => {
  controllers.delete(controller);
};
function addAnimatedStyles(node, styles) {
  if ("update" in node) {
    styles.add(node);
  } else {
    node.getChildren().forEach((child) => addAnimatedStyles(child, styles));
  }
}
var AnimatedValue = class extends Animated {
  constructor(_value) {
    var _this;
    super();
    _this = this;
    this.animatedStyles = /* @__PURE__ */ new Set();
    this.value = void 0;
    this.startPosition = void 0;
    this.lastPosition = void 0;
    this.lastVelocity = void 0;
    this.startTime = void 0;
    this.lastTime = void 0;
    this.done = false;
    this.setValue = function(value, flush) {
      if (flush === void 0) {
        flush = true;
      }
      _this.value = value;
      if (flush)
        _this.flush();
    };
    this.value = _value;
    if (is.num(_value)) {
      this.startPosition = _value;
      this.lastPosition = _value;
    }
  }
  getValue() {
    return this.value;
  }
  interpolate() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return createAnimatedInterpolation(this, ...args);
  }
  reset(isActive) {
    if (is.num(this.value)) {
      this.startPosition = this.value;
      this.lastPosition = this.value;
      this.lastVelocity = isActive ? this.lastVelocity : void 0;
      this.lastTime = isActive ? this.lastTime : void 0;
      this.startTime = now();
    }
    this.done = false;
    this.animatedStyles.clear();
  }
  clearStyles() {
    this.animatedStyles.clear();
  }
  flush() {
    if (this.animatedStyles.size === 0) {
      addAnimatedStyles(this, this.animatedStyles);
    }
    this.animatedStyles.forEach((animatedStyle) => animatedStyle.update());
  }
};
var linear = (t) => t;
var emptyObj = Object.freeze({});
var nextId = 1;
var Controller = class _Controller {
  constructor(props) {
    this.id = nextId++;
    this.idle = true;
    this.runCount = 0;
    this.destroyed = false;
    this.props = {};
    this.queue = [];
    this.timestamps = {};
    this.values = {};
    this.merged = {};
    this.animated = {};
    this.animations = {};
    this.configs = [];
    this.onEndQueue = [];
    this.cancelledAt = 0;
    if (props)
      this.update(props).start();
  }
  /**
   * Push props into the update queue. The props are used after `start` is
   * called and any delay is over. The props are intelligently diffed to ensure
   * that later calls to this method properly override any delayed props.
   * The `propsArg` argument is always copied before mutations are made.
   */
  update(propsArg) {
    if (!propsArg || this.destroyed)
      return this;
    const props = interpolateTo(propsArg);
    this._ensureAnimated(props.from, true);
    this._ensureAnimated(props.to);
    props.timestamp = now();
    if (is.fun(props.delay) && is.obj(props.to)) {
      const from = props.from || emptyObj;
      for (const key in props.to) {
        this.queue.push(_extends({}, props, {
          to: {
            [key]: props.to[key]
          },
          from: key in from ? {
            [key]: from[key]
          } : void 0,
          delay: Math.max(0, Math.round(props.delay(key)))
        }));
      }
    } else {
      props.delay = is.num(props.delay) ? Math.max(0, Math.round(props.delay)) : 0;
      if (!props.to)
        props.to = void 0;
      if (!props.from)
        props.from = void 0;
      this.queue.push(props);
    }
    return this;
  }
  /**
   * Flush the update queue.
   * If the queue is empty, try starting the frameloop.
   */
  start(onEnd) {
    if (this.queue.length)
      this._flush(onEnd);
    else
      this._start(onEnd);
    return this;
  }
  /** Stop one animation or all animations */
  stop() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }
    let finished = false;
    if (is.boo(keys[0])) {
      var _keys = keys;
      finished = _keys[0];
      keys = _keys.slice(1);
    }
    if (keys.length) {
      for (const key of keys) {
        const index2 = this.configs.findIndex((config) => key === config.key);
        this._stopAnimation(key);
        this.configs[index2] = this.animations[key];
      }
    } else if (this.runCount) {
      this.cancelledAt = now();
      this.configs.forEach((config) => this._stopAnimation(config.key));
      this.configs = Object.values(this.animations);
      this._stop(finished);
    }
    return this;
  }
  /** Revert the controller to its initial state */
  reset() {
    this.stop();
    this.destroyed = false;
    this.props = {};
    this.queue = [];
    this.timestamps = {};
    this.values = {};
    this.merged = {};
    this.animated = {};
    this.animations = {};
    this.configs = [];
    return this;
  }
  /** Prevent all current and future animation */
  destroy() {
    if (!this.destroyed) {
      this.stop();
      this.destroyed = true;
    }
  }
  /** @internal Called by the frameloop */
  onFrame(isActive, updateCount) {
    if (updateCount) {
      const onFrame = this.props.onFrame;
      if (onFrame)
        onFrame(_extends({}, this.values));
    }
    if (!isActive)
      this._stop(true);
  }
  /**
   * Set a prop for the next animations where the prop is undefined. The given
   * value is overridden by the next update where the prop is defined.
   *
   * Ongoing animations are not changed.
   */
  setProp(key, value) {
    this.props[key] = value;
    this.timestamps[key] = now();
    return this;
  }
  // Create an Animated node if none exists.
  _ensureAnimated(values, shouldUpdate) {
    if (shouldUpdate === void 0) {
      shouldUpdate = false;
    }
    if (!is.obj(values))
      return;
    for (const key in values) {
      const value = values[key];
      let animated = this.animated[key];
      if (animated && shouldUpdate && this.animations[key].isNew) {
        if (animated.setValue) {
          animated.setValue(value);
        } else {
          animated = null;
        }
      }
      if (!animated) {
        animated = createAnimated(value);
        if (animated) {
          if (this.animated[key]) {
            moveChildren(this.animated[key], animated);
          }
          this.animated[key] = animated;
          this._stopAnimation(key, true);
        } else {
          console.warn("Given value not animatable:", value);
        }
      }
    }
  }
  // Listen for all animations to end.
  _onEnd(onEnd) {
    if (this.runCount)
      this.onEndQueue.push(onEnd);
    else
      onEnd(true);
  }
  // Add this controller to the frameloop.
  _start(onEnd) {
    if (onEnd)
      this._onEnd(onEnd);
    if (this.idle && this.runCount) {
      this.idle = false;
      start(this);
    }
  }
  // Remove this controller from the frameloop, and notify any listeners.
  _stop(finished) {
    this.idle = true;
    stop(this);
    const onEndQueue = this.onEndQueue;
    if (onEndQueue.length) {
      this.onEndQueue = [];
      onEndQueue.forEach((onEnd) => onEnd(finished));
    }
  }
  // Execute the current queue of prop updates.
  _flush(onEnd) {
    const queue = this.queue.reduce(reduceDelays, []);
    this.queue.length = 0;
    let runsLeft = Object.keys(queue).length;
    this.runCount += runsLeft;
    const onRunEnd = (finished) => {
      this.runCount--;
      if (--runsLeft)
        return;
      if (onEnd)
        onEnd(finished);
      if (!this.runCount && finished) {
        const onRest = this.props.onRest;
        if (onRest)
          onRest(this.merged);
      }
    };
    queue.forEach((props, delay) => {
      if (delay) {
        setTimeout(() => {
          if (props.timestamp < this.cancelledAt)
            return;
          this._run(props, onRunEnd);
        }, delay);
      } else {
        this._run(props, onRunEnd);
      }
    });
  }
  // Update the props and animations
  _run(props, onEnd) {
    if (is.arr(props.to) || is.fun(props.to)) {
      this._runAsync(props, onEnd);
    } else if (this._diff(props)) {
      this._animate(props)._start(onEnd);
    } else {
      this._onEnd(onEnd);
    }
  }
  // Start an async chain or an async script.
  _runAsync(_ref, onEnd) {
    let to = _ref.to, props = _objectWithoutPropertiesLoose(_ref, ["to"]);
    if (this._diff(props)) {
      this._animate(props);
    }
    if (props.cancel === true) {
      this.props.asyncTo = void 0;
      return onEnd(false);
    }
    const timestamp = props.timestamp;
    if (!this._diff({
      asyncTo: to,
      timestamp
    })) {
      return onEnd(false);
    }
    const isCancelled = () => (
      // Cancelling methods touch the `cancelledAt` property
      timestamp < this.cancelledAt || // Async scripts are also cancelled when a new chain/script begins
      is.fun(to) && to !== this.props.asyncTo
    );
    let last;
    const next = (props2) => {
      if (isCancelled())
        throw this;
      return (last = new Promise((done) => {
        this.update(props2).start(done);
      })).then(() => {
        if (isCancelled())
          throw this;
      });
    };
    let queue = Promise.resolve();
    if (is.arr(to)) {
      to.forEach((props2) => queue = queue.then(() => next(props2)));
    } else if (is.fun(to)) {
      queue = queue.then(() => to(next, this.stop.bind(this)).then(() => last));
    }
    queue.catch((err) => err !== this && console.error(err)).then(() => onEnd(!isCancelled()));
  }
  // Merge every fresh prop. Returns true if one or more props changed.
  // These props are ignored: (delay, config, immediate, reverse)
  _diff(_ref2) {
    let timestamp = _ref2.timestamp, delay = _ref2.delay, config = _ref2.config, immediate = _ref2.immediate, reverse = _ref2.reverse, props = _objectWithoutPropertiesLoose(_ref2, ["timestamp", "delay", "config", "immediate", "reverse"]);
    let changed = false;
    const diffTimestamp = (keyPath) => {
      const previous = this.timestamps[keyPath];
      if (is.und(previous) || timestamp >= previous) {
        this.timestamps[keyPath] = timestamp;
        return true;
      }
      return false;
    };
    const diffProp = (keys, value, parent) => {
      if (is.und(value))
        return;
      const lastKey = keys[keys.length - 1];
      if (is.obj(value)) {
        if (!is.obj(parent[lastKey]))
          parent[lastKey] = {};
        for (const key in value) {
          diffProp(keys.concat(key), value[key], parent[lastKey]);
        }
      } else if (diffTimestamp(keys.join("."))) {
        const oldValue = parent[lastKey];
        if (!isEqual(value, oldValue)) {
          changed = true;
          parent[lastKey] = value;
        }
      }
    };
    if (reverse) {
      const to = props.to;
      props.to = props.from;
      props.from = is.obj(to) ? to : void 0;
    }
    for (const key in props) {
      diffProp([key], props[key], this.props);
    }
    if ("reset" in props)
      this.props.reset = false;
    if ("cancel" in props)
      this.props.cancel = void 0;
    return changed;
  }
  // Return true if the given prop was changed by this update
  _isModified(props, prop) {
    return this.timestamps[prop] === props.timestamp;
  }
  // Update the animation configs. The given props override any default props.
  _animate(props) {
    const _this$props = this.props, _this$props$from = _this$props.from, from = _this$props$from === void 0 ? emptyObj : _this$props$from, _this$props$to = _this$props.to, to = _this$props$to === void 0 ? emptyObj : _this$props$to, attach = _this$props.attach, onStart = _this$props.onStart;
    let isPrevented = (_) => false;
    if (props.cancel && this._isModified(props, "cancel")) {
      if (props.cancel === true) {
        this.stop();
        this.cancelledAt = props.timestamp;
        return this;
      }
      const keys = toArray(props.cancel);
      if (is.arr(keys) && keys.length) {
        isPrevented = (key) => keys.indexOf(key) >= 0;
        this.stop(...keys);
      }
    }
    this.merged = freeze(_extends({}, from, to));
    let changed = false;
    const started = [];
    const target = attach && attach(this);
    for (const key in this.merged) {
      if (isPrevented(key))
        continue;
      const state = this.animations[key];
      if (!state) {
        console.warn(`Failed to animate key: "${key}"
Did you forget to define "from.${key}" for an async animation?`);
        continue;
      }
      let animated = state.animated, animatedValues = state.animatedValues;
      const value = this.merged[key];
      const goalValue = computeGoalValue(value);
      const currValue = animated.getValue();
      if (!props.reset && isEqual(goalValue, currValue)) {
        if (!state.idle) {
          changed = true;
          this._stopAnimation(key);
        }
        continue;
      }
      if (props.reset || !isEqual(goalValue, state.isNew ? currValue : state.goalValue)) {
        let _ref3 = is.und(props.immediate) ? this.props : props, immediate = _ref3.immediate;
        immediate = !!callProp(immediate, key);
        const isActive = animatedValues.some((v) => !v.done);
        const fromValue = !is.und(from[key]) ? computeGoalValue(from[key]) : goalValue;
        const isInterpolated = isAnimatableString(value);
        if (isInterpolated) {
          const output = [props.reset ? fromValue : animated.getValue(), goalValue];
          let input = animatedValues[0];
          if (input) {
            input.setValue(0, false);
            input.reset(isActive);
          } else {
            input = new AnimatedValue(0);
          }
          try {
            const prev = animated;
            animated = input.interpolate({
              output
            });
            moveChildren(prev, animated);
          } catch (err) {
            console.warn('Failed to interpolate string from "%s" to "%s"', output[0], output[1]);
            console.error(err);
            continue;
          }
          if (immediate) {
            input.setValue(1, false);
          }
        } else {
          if (is.arr(value)) {
            if (animated instanceof AnimatedValueArray) {
              if (props.reset)
                animated.setValue(fromValue, false);
              animatedValues.forEach((v) => v.reset(isActive));
            } else {
              const prev = animated;
              animated = createAnimated(fromValue);
              moveChildren(prev, animated);
            }
          } else {
            if (animated instanceof AnimatedValue) {
              if (props.reset)
                animated.setValue(fromValue, false);
              animated.reset(isActive);
            } else {
              const prev = animated;
              animated = new AnimatedValue(fromValue);
              moveChildren(prev, animated);
            }
          }
          if (immediate) {
            animated.setValue(goalValue, false);
          }
        }
        const config = callProp(props.config, key) || callProp(this.props.config, key) || emptyObj;
        if (!immediate) {
          started.push(key);
        }
        changed = true;
        animatedValues = toArray(animated.getPayload());
        this.animations[key] = {
          key,
          idle: false,
          goalValue,
          toValues: toArray(target instanceof _Controller ? target.animations[key].animated.getPayload() : isInterpolated && 1 || goalValue),
          fromValues: animatedValues.map((v) => v.getValue()),
          animated,
          animatedValues,
          immediate,
          duration: config.duration,
          easing: withDefault(config.easing, linear),
          decay: config.decay,
          mass: withDefault(config.mass, 1),
          tension: withDefault(config.tension, 170),
          friction: withDefault(config.friction, 26),
          initialVelocity: withDefault(config.velocity, 0),
          clamp: withDefault(config.clamp, false),
          precision: withDefault(config.precision, 5e-3),
          config
        };
      }
    }
    if (changed) {
      if (onStart && started.length) {
        started.forEach((key) => onStart(this.animations[key]));
      }
      const keys = Object.keys(this.animations);
      this.configs.length = keys.length;
      keys.forEach((key, i) => {
        const config = this.animations[key];
        this.configs[i] = config;
        this.values[key] = config.animated.getValue();
        this.animated[key] = config.animated;
      });
    }
    return this;
  }
  /**
   * Stop an animation by its key.
   *
   * This mutates the `timestamps.to[key]`, `props.to[key]`, and `animations[key]` properties.
   * Notably, it does *not* mutate the `configs[key]` or `animated[key]` properties.
   */
  _stopAnimation(key, isNew) {
    const animated = this.animated[key];
    if (!animated) {
      return console.warn(`Cannot stop an animation for a key that isn't animated: "${key}"`);
    }
    this.timestamps["to." + key] = now();
    const state = this.animations[key] || emptyObj;
    if (state.idle && animated === state.animated)
      return;
    if (is.und(isNew)) {
      isNew = !!state.isNew;
    }
    const animatedValues = toArray(animated.getPayload());
    animatedValues.forEach((v) => v.done = true);
    const goalValue = animated.getValue();
    if (this.props.to) {
      this.props.to[key] = goalValue;
    }
    this.animations[key] = {
      key,
      idle: true,
      isNew,
      goalValue,
      animated,
      animatedValues
    };
  }
};
function createAnimated(value) {
  return is.arr(value) ? new AnimatedValueArray(value.map((value2) => {
    const animated = createAnimated(value2);
    const payload = animated.getPayload();
    return animated instanceof AnimatedInterpolation ? payload[0] : payload;
  })) : isAnimatableString(value) ? (
    // Convert "red" into "rgba(255, 0, 0, 1)" etc
    new AnimatedValue(0).interpolate({
      output: [value, value]
    })
  ) : (
    // The `AnimatedValue` class supports any type, but only numbers are
    // interpolated by the frameloop.
    new AnimatedValue(value)
  );
}
function moveChildren(prev, next) {
  const children = prev.getChildren().slice();
  children.forEach((child) => {
    prev.removeChild(child);
    next.addChild(child);
    const payload = child.getPayload();
    if (is.arr(payload)) {
      const i = payload.indexOf(prev);
      if (i >= 0) {
        const copy = [...payload];
        copy[i] = next;
        child["payload"] = copy;
      }
    } else if (is.obj(payload)) {
      const entry = Object.entries(payload).find((entry2) => entry2[1] === prev);
      if (entry) {
        child["payload"] = _extends({}, payload, {
          [entry[0]]: next
        });
      }
    }
  });
}
function reduceDelays(merged, props) {
  const prev = merged[props.delay];
  if (prev) {
    props.to = merge(prev.to, props.to);
    props.from = merge(prev.from, props.from);
    Object.assign(prev, props);
  } else {
    merged[props.delay] = props;
  }
  return merged;
}
function merge(dest, src) {
  return is.obj(dest) && is.obj(src) ? _extends({}, dest, src) : src || dest;
}
function isAnimatableString(value) {
  if (!is.str(value))
    return false;
  return value.startsWith("#") || /\d/.test(value) || !!colorNames[value];
}
function computeGoalValue(value) {
  return is.arr(value) ? value.map(computeGoalValue) : isAnimatableString(value) ? createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function isEqual(a, b) {
  if (is.arr(a)) {
    if (!is.arr(b) || a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  return a === b;
}
var useSprings = (length, propsArg, deps) => {
  const hasNewSprings = length !== usePrev(length);
  const isFn = is.fun(propsArg);
  const state = (0, import_react.useRef)({
    springs: [],
    ref: null
  }).current;
  const props = isFn ? [] : propsArg;
  const springs = (0, import_react.useMemo)(() => fillArray(length, (i) => {
    const s = new Controller();
    const p = props[i] || (props[i] = callProp(propsArg, i, s));
    return s.update(p);
  }), [length]);
  const _useMemo = (0, import_react.useMemo)(() => ({
    /** Apply any pending updates */
    start: () => Promise.all(state.springs.map((s) => new Promise((done) => s.start(done)))),
    /** Update the spring controllers */
    update: (props2) => {
      const isFn2 = is.fun(props2);
      const isArr = is.arr(props2);
      state.springs.forEach((spring, i) => {
        spring.update(isFn2 ? callProp(props2, i, spring) : isArr ? props2[i] : props2);
        if (!state.ref)
          spring.start();
      });
    },
    /** Stop one key or all keys from animating */
    stop: function stop3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return state.springs.forEach((s) => s.stop(...args));
    }
  }), []), start2 = _useMemo.start, update2 = _useMemo.update, stop2 = _useMemo.stop;
  const ref = props[0] ? props[0].ref : isFn ? state.ref : null;
  (0, import_react.useImperativeHandle)(ref, () => ({
    start: start2,
    stop: stop2,
    get controllers() {
      return state.springs;
    }
  }));
  (0, import_react.useEffect)(() => {
    if (!isFn || hasNewSprings) {
      props.forEach((p, i) => {
        springs[i].setProp("config", p.config);
        springs[i].setProp("immediate", p.immediate);
      });
    }
    if (hasNewSprings) {
      state.springs.forEach((s) => s.destroy());
      state.springs = springs;
      state.ref = ref;
      if (!ref) {
        springs.forEach((s) => s.start());
      }
    } else if (!isFn) {
      update2(props);
    }
  }, deps);
  (0, import_react.useEffect)(() => {
    return () => state.springs.forEach((s) => s.destroy());
  }, []);
  const values = springs.map((s) => _extends({}, s.animated));
  return isFn ? [values, update2, stop2] : values;
};
var useSpring = (props, deps) => {
  const isFn = is.fun(props);
  const _useSprings = useSprings(1, isFn ? props : [props], deps), result = _useSprings[0], set = _useSprings[1], stop2 = _useSprings[2];
  return isFn ? [result[0], set, stop2] : result;
};
assign({
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  createAnimatedInterpolation: function createAnimatedInterpolation$$1(parents) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return new AnimatedInterpolation(parents, args);
  }
});
var AnimatedProps = class extends AnimatedObject {
  constructor(props, callback) {
    super(props.style && createAnimatedStyle ? _extends({}, props, {
      style: createAnimatedStyle(props.style)
    }) : props);
    this.update = void 0;
    this.update = callback;
    this.attach();
  }
};
var createAnimatedComponent = (Component) => {
  const AnimatedComponent = (0, import_react.forwardRef)((props, _ref) => {
    const forceUpdate = useForceUpdate();
    const mounted = (0, import_react.useRef)(true);
    const propsAnimated = (0, import_react.useRef)(null);
    const node = (0, import_react.useRef)(null);
    const attachProps = (0, import_react.useCallback)((props2) => {
      const oldPropsAnimated = propsAnimated.current;
      const callback = () => {
        if (node.current) {
          const didUpdate = applyAnimatedValues(node.current, propsAnimated.current.getAnimatedValue());
          if (didUpdate === false)
            forceUpdate();
        }
      };
      propsAnimated.current = new AnimatedProps(props2, callback);
      oldPropsAnimated && oldPropsAnimated.detach();
    }, []);
    (0, import_react.useEffect)(() => () => {
      mounted.current = false;
      propsAnimated.current && propsAnimated.current.detach();
    }, []);
    (0, import_react.useImperativeHandle)(_ref, () => createAnimatedRef(node, mounted, forceUpdate));
    attachProps(props);
    const _getValue = propsAnimated.current.getValue(), scrollTop = _getValue.scrollTop, scrollLeft = _getValue.scrollLeft, animatedProps = _objectWithoutPropertiesLoose(_getValue, ["scrollTop", "scrollLeft"]);
    return import_react.default.createElement(Component, _extends({}, animatedProps, {
      ref: (childRef) => node.current = handleRef(childRef, _ref)
    }));
  });
  return AnimatedComponent;
};
function withExtend(animated, options) {
  if (options === void 0) {
    options = {};
  }
  const self2 = animated;
  self2.extend = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    args.forEach((arg) => extend(arg));
    return self2;
  };
  return self2;
  function extend(arg, overrideKey) {
    if (is.arr(arg)) {
      return arg.forEach((arg2) => extend(arg2));
    }
    if (is.obj(arg)) {
      for (const key2 in arg)
        extend(arg[key2], key2);
      return;
    }
    let key = is.str(overrideKey) ? overrideKey : is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) ? arg.name : "";
    if (options.lowercase) {
      key = key[0].toLowerCase() + key.slice(1);
    }
    self2[key] = animated(arg);
  }
}
var elements = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var animated$1 = withExtend(createAnimatedComponent).extend(elements);
var apply = animated$1.extend;
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
function dangerousStyleValue(name, value, isCustomProperty) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues$1(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const _ref = props, style = _ref.style, children = _ref.children, scrollTop = _ref.scrollTop, scrollLeft = _ref.scrollLeft, attributes = _objectWithoutPropertiesLoose(_ref, ["style", "children", "scrollTop", "scrollLeft"]);
  if (scrollTop !== void 0)
    instance.scrollTop = scrollTop;
  if (scrollLeft !== void 0)
    instance.scrollLeft = scrollLeft;
  if (children !== void 0)
    instance.textContent = children;
  for (let styleName in style) {
    if (!style.hasOwnProperty(styleName))
      continue;
    var isCustomProperty = styleName.indexOf("--") === 0;
    var styleValue = dangerousStyleValue(styleName, style[styleName], isCustomProperty);
    if (styleName === "float")
      styleName = "cssFloat";
    if (isCustomProperty)
      instance.style.setProperty(styleName, styleValue);
    else
      instance.style[styleName] = styleValue;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  for (let name in attributes) {
    const attributeName = isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n) => "-" + n.toLowerCase()));
    instance.setAttribute(attributeName, attributes[name]);
  }
}
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
var colors = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors.hasOwnProperty(color))
    return colors[color];
  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = hex8.exec(color))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  let r = (int32Color & 4278190080) >>> 24;
  let g = (int32Color & 16711680) >>> 16;
  let b = (int32Color & 65280) >>> 8;
  let a = (int32Color & 255) / 255;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}
var stringShapeRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var colorNamesRegex = new RegExp(`(${Object.keys(colors).join("|")})`, "g");
var createStringInterpolator$1 = (config) => {
  const outputRange = config.output.map((rangeValue) => rangeValue.replace(colorRegex, colorToRgba)).map((rangeValue) => rangeValue.replace(colorNamesRegex, colorToRgba));
  const outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
  outputRange.forEach((value) => {
    value.match(stringShapeRegex).forEach((number, i) => outputRanges[i].push(+number));
  });
  const interpolations = outputRange[0].match(stringShapeRegex).map((_value, i) => createInterpolator(_extends({}, config, {
    output: outputRanges[i]
  })));
  return (input) => {
    let i = 0;
    return outputRange[0].replace(stringShapeRegex, () => interpolations[i++](input)).replace(/rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`);
  };
};
assign({
  defaultElement: "div",
  colorNames: colors,
  applyAnimatedValues: applyAnimatedValues$1,
  createStringInterpolator: createStringInterpolator$1
});

// node_modules/react-grid-dnd/esm/GridItem.js
function GridItem(_a) {
  var children = _a.children, style = _a.style, className = _a.className, other = __rest(_a, ["children", "style", "className"]);
  var context = React7.useContext(GridItemContext);
  if (!context) {
    throw Error("Unable to find GridItem context. Please ensure that GridItem is used as a child of GridDropZone");
  }
  var top = context.top, disableDrag = context.disableDrag, endTraverse = context.endTraverse, onStart = context.onStart, mountWithTraverseTarget = context.mountWithTraverseTarget, left = context.left, i = context.i, onMove = context.onMove, onEnd = context.onEnd, grid = context.grid, isDragging = context.dragging;
  var columnWidth = grid.columnWidth, rowHeight = grid.rowHeight;
  var dragging = React7.useRef(false);
  var startCoords = React7.useRef([left, top]);
  var _b = __read(useSpring(function() {
    if (mountWithTraverseTarget) {
      var mountXY = mountWithTraverseTarget;
      endTraverse();
      return {
        xy: mountXY,
        immediate: true,
        zIndex: "1",
        scale: 1.1,
        opacity: 0.8
      };
    }
    return {
      xy: [left, top],
      immediate: true,
      zIndex: "0",
      scale: 1,
      opacity: 1
    };
  }), 2), styles = _b[0], set = _b[1];
  function handleMove(state, e) {
    var x = startCoords.current[0] + state.delta[0];
    var y = startCoords.current[1] + state.delta[1];
    set({
      xy: [x, y],
      zIndex: "1",
      immediate: true,
      opacity: 0.8,
      scale: 1.1
    });
    onMove(state, x, y);
  }
  function handleEnd(state) {
    var x = startCoords.current[0] + state.delta[0];
    var y = startCoords.current[1] + state.delta[1];
    dragging.current = false;
    onEnd(state, x, y);
  }
  var bind = useGestureResponder({
    onMoveShouldSet: function(state) {
      if (disableDrag) {
        return false;
      }
      onStart();
      startCoords.current = [left, top];
      dragging.current = true;
      return true;
    },
    onMove: handleMove,
    onTerminationRequest: function() {
      if (dragging.current) {
        return false;
      }
      return true;
    },
    onTerminate: handleEnd,
    onRelease: handleEnd
  }, {
    enableMouse: true
  }).bind;
  React7.useEffect(function() {
    if (!dragging.current) {
      set({
        xy: [left, top],
        zIndex: "0",
        opacity: 1,
        scale: 1,
        immediate: false
      });
    }
  }, [dragging.current, left, top]);
  var props = __assign({ className: "GridItem" + (isDragging ? " dragging" : "") + (!!disableDrag ? " disabled" : "") + className ? " " + className : "" }, bind, { style: __assign({ cursor: !!disableDrag ? "grab" : void 0, zIndex: styles.zIndex, position: "absolute", width: columnWidth + "px", opacity: styles.opacity, height: rowHeight + "px", boxSizing: "border-box", transform: createAnimatedInterpolation([styles.xy, styles.scale], function(xy, s) {
    return "translate3d(" + xy[0] + "px, " + xy[1] + "px, 0) scale(" + s + ")";
  }) }, style) }, other);
  return typeof children === "function" ? children(animated$1.div, props, {
    dragging: isDragging,
    disabled: !!disableDrag,
    i,
    grid
  }) : React7.createElement(animated$1.div, __assign({}, props), children);
}
export {
  GridContext,
  GridContextProvider,
  GridDropZone,
  GridItem,
  move,
  swap
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=react-grid-dnd.js.map
